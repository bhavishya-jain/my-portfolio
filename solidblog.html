
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="styles.css" rel="stylesheet" />
    <title>Blogs | Bhavishya Jain</title>
  </head>

  <body>
    <nav class="navigation container">
      <div class="nav-brand"><a href="/">Bhavishya Jain</a></div>
      <ul class="list-non-bullet nav-pills">
        <li class="list-item-inline">
          <a class="link" href="/">Home</a>
        </li>
        <li class="list-item-inline">
          <a class="link" href="/projects.html">Projects</a>
        </li>
        <li class="list-item-inline">
          <a class="link link-active" href="/blogs.html">Blogs</a>
        </li>
      </ul>
    </nav>

    <header class="hero">
      <h1 class="hero-heading">
        This is <span class="heading-inverted">SOLID Principles</span> Blog
      </h1>
    </header>

    <article class="container-center showcase-blog">
        <h1>SOLID Principles</h1><br>
        1. Single responsibility principle:

        A class should have one and only one reason to change, meaning that a class should have only one responsibility.
        This means decoupling the unrelated functionalities and separating them into different classes. <br><br>
        
        2. Open-closed principle:
        
        Objects or entities should be open for extension but closed for modification.
        This should be used only when the requirements are reasonable predictable to us.
        The code should be isolated from requirements change <br><br>
        
        3. Liskov substitution principle:
        
        Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.
        This means that every subclass or derived class should be substitutable for their base or parent class.
        If the code is going to be consumed by others, then this becomes important. <br><br>
        
        4. Interface segregation principle:
        
        A client should never be forced to implement an interface that it doesn’t use, or clients shouldn’t be forced to depend on methods they do not use.
        <br><br>
        5. Dependency inversion principle:
        
        Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions.
        
    </article>

    <footer class="footer">
        <div class="footer-header">Social Media Presence</div>
        <ul class="social-links list-non-bullet">
          <li class="list-item-inline">
            <a class="link" href="https://github.com/bhavishya-jain/"> Github </a>
          </li>
          <li class="list-item-inline">
            <a class="link" href="https://twitter.com/bhavishyajain"> Twitter </a>
          </li>
          <li class="list-item-inline">
            <a class="link" href="https://www.linkedin.com/in/bhavishya-jain/">
              Linkedin
            </a>
          </li>
        </ul>
        <p>© | 2021 | bhavishyajain</p>
      </footer>
  </body>
</html>
